# ✨ Операционни системи ✨

Документация за предмета "Опрерационни системи" (11-ти клас) за учебната **_ТУЕС, 2022/23_** година

## Съдържание

### [Теория](#теория)

1.  [Какво е операционната система?](#какво-е-операционната-система)
    1. [Типове хардуер и техните отговорностти](#типове-хардуер-и-техните-отговорности)
    1. [Работата на ОС](#работата-на-ос)
    1. [Процес - що е то?](#)
    1. [Устройство на централния процесора](#)
       1. [АЛУ](#)
       2. [Памет](#)
          - [Кеш (L3-1)](#)
          - [Регистри](#)
    1. [Видове процеси](#)
    1. [Пример за процес](#)
    1. [Прекъсване](#)
       1. [Софтуерни](#)
       1. [Хардуерни](#)
    1. [Управление на входно-изходни устройства](#)
    1. [Кеширане](#)
1.  [Вътрешно устройство на ОС](#)
    1. [Цели на ОС](#)
       1. [Многозадачност (multitasking)](#)
       1. [Многопотребителност](#)
    1. [Структура](#)
       1. [Ядро (Kernel)](#)
       1. [Обвивка (Shell)](#)
    1. [Ядрото](#)
       1. [Задачи](#)
       1. [Процеси](#)
       1. [Памет](#)
       1. [Файлове](#)
       1. [Устройства](#)
       1. [Сигнали](#)
       1. [Системни извиквания](#)
1.  [Видове архитектури на ядрото и виртуализация](#)
    1. [Монолитни ядра](#)
    1. [Многослойни ядра](#)
    1. [Микроядра](#)
    1. [Виртуализация](#)
1.  [Процесите в детайл](#)

---

### [Практика](#практика)

1.  [Macros | Макроси](#macros--макроси)
1.  [Basic Linux команди](#basic-linux-команди)
1.  [Файлове и файлови дескриптори](#файлове-и-файлови-дескриптори)

---

# Теория

## Какво е операционната система?

Операционната система е програма, която има следните 2 задачи:

- да управлява хардуера
- да предоставя интерфес за приложните програми, за да може те да работят с хардуера

![user <-> application <-> os <-> hardware](assets/os_hardware.png)

### Типове хардуер и техните отговорности

Има 5 типа хардуер, които ще изучаваме този "семестър":

- **_Централнен процесор (CPU - Central Processing Unit)_** - най-важният компонент от един копютър. Изчислява и изпълнява инструкции. Той има за цел да променя данните от паметта под някаква форма.
- **_Оперативна памет (RAM - Random Access Memory)_** - RAM паметта е най-просто казано бърза и енергозависима памет (т.е. ако спре захранването на дадена машина, данните ще бъдат изгубени) и точно, заради това идва и решението на този проблем - съхраняващите устройста. RAM паметта се използва за временно съхранение на изпълняващите програми и данни, които се използват от тях (инструкции, данни и контекст на процес)
- **_Съхраняващи усторйства (Storage Devices)_** - това са сравнително по-бавни устройства за записване и четене на данни, но за разлика от RAM паметта, те са енергонезависими и не се влияят от захранващото състояние на машината. Използват се за дълготрайно съхранение на данни, source code-ове, изпълними файлове и т.н.
- **_Входно-изходни устройства (Input-Output (I/O) Devices)_** - имат за цел да взимат и предават данни (информация) от и на потребителя
- **_Системна шина (System BUS)_** - това е хардуерен компонент, който е междинен слой за комуникация между компонентите. Подобна аналогия е с пътната инфраструктурна мрежа на една държава, която представлява логистичен мост между различните населени места.

### Работата на ОС

Работата на операционната система е ОС е да разделя и управлява хардуера, както и да използва идеята за ресурси. Тази идея представлява интерфейс, който операзионната система използва за приложните програми. Два (2) много важни такива интерфейса (абстракции) са:

- ресурсната абстракция
- файлова абстракция

Пример:

```
malloc() – заделя памет в RAM паметта; работа с файлове.
```

Операционната система също имплементира ред защити за хардуерните устройства. Като примерно не можем да достъпим памет, която не ни принадлежи и т.н.

### Процес - що е то?

Процесът е единствената единица за изпълнение в операционната система. Той представлява програма, която се изпълнява в момента. Процесът съдържа:

Съвкупност от всички операции, които даден процес може да изпълнява се нарича архитектура

![от код към процес](assets/proc.png)

- _Loader_ – Това е специална програма, която приема изпълними файлове от Linker-а, зарежда ги в основната памет и подготвя този код за изпълнение от компютър. Loader-ът разпределя място в паметта за програмата. Той отговаря за зареждането на програми и библиотеки в операционната система.

- _Формат на файл_ – информация, която казва как да бъдат имплементирани файловете

- _Процес_ – изпълним файл по време на изпълнение

### Устройство на централния процесор

1. **_АЛУ_** - Аритметико-логическия блок (Arithmetic Logic Unit) - използва se за извършване на аритметични операции и логически операции – събиране, изваждане, умножение, деление и сравняване на две числа. Това устройство обработва данните от регистрите на процесора и контролира скоростта на изчислителния процес. Като реално е изградено от логически елементи - "запоени писти за електрони".

1. **_Регистри (Registers)_** - те са най-бързата памет в една компютърна система и се разделят на 2 вида:

   1. **с общо предазначение** - използват се най-често за временно съхранение на данни (от ОС и приложните програми), от които процесора има най-бърз достъп до. Тези регистри също се делят на 2 подвида - регистри за данни и адресни регистри.
   1. **контролни регистри:** - използват се от ОС за управление на процесите и от самия централен процесор, за да контролира работата си
      - **_Програмен брояч (Program Counter (PC))_** - съхранява поредния номер на следващата инструкция, която трябва да се изпълни
      - **_Регистър за инструкция (Instruction Register (IR))_** - пази се инструкцията, която се изпълнява в момента. Всеки процесор има различен набор от инструкции и затова те си имат зададен номер – т.е. какво прави, примерно: 0 – запиши, 1 – събери и т.н, който зависи от архитектурата.
      - **_Регистър на състоянието (Program Status Word (PSW))_** - в него се съхраняват сервизната информация за операционната систмеа, [мета](https://i.kym-cdn.com/photos/images/original/002/237/750/454.jpg)данни.

1. **_Кеш памет (Cache Memory)_** - това е малка, но доста бърза памет, която се намира вътре във CPU-то. Тя се използва за да се запазят данните, които са използвани най-често, за да се ускори достъпа до тях. Това е доста важно, защото всяко извикване на данни от RAM паметта е доста по-бавно от това да се извика от кеш паметта. Kеш паметта бива L1, L2 и L3 (L3 от около 2000 година)

   - L1 - директно комуникира с регистрите. L1 се разделя на 2 части - L1D (Data) и L1I (Instruction). L1D съхранява данните, които са използвани най-често, а L1I съхранява инструкциите, които са използвани най-често. L1I минава през процес на извличане и декодиране на самите инструкции.
   - L2 & L3 - те представляват медиаторите между L1 и RAM паметта. Те са доста по-бавни от L1 (но и по-големи - L1:KB vs L2/3:MB), но са в пъти по-бързи от RAM паметта.

![схема на процесора](./assets/cpu.png)

На схемата е описано как процесорът изпълнява инструкции. Те достигат до него по системната шина. След като достигнат до процесора, те минават през L2 (първо), L1 (различни типове памет, кешпамет) и стигат до хардуера, където биват декодирани. След това отиват към АЛУ, който чете от регистрите (т.е. инструкциите влизат първо там). АЛУ изпълнява посочените в инструкцията действия, след което записва резултатите в посочените в инструкцията координати.

### Видове процеси

Разпределението на пълномощията в ОС се реализира с помощта на съответна процесорна архитектура с два режима на работа:

- **_Привилегирован_** режим на процесора - може да се прави всичко, само Kernel-ът може да работи в този режим; за изпълнимата програма е достъпно цялото адресно пространство.
- **_Непривилегирован_** режим на процесора - може да се изпълнява конкретно подмножество, което процесорът позволява (нашите програми са в такъв режим); достъпността на адресното пространство е ограничено до размери определени при стартиране на програмата.

### Как и къде се изпълнява процеса? (пример)

1. Пази се следната програма на диска (файл - source code):

```c
int main() {
	int a = 5;
	int b = 10;
	int c  = a + b;
	return c;
}
```

2. Компилира се и се получава изпълним файл (executable file), в който се съдържат следните параметри (данни и инструкции):

- данни: a = 5, b = 10 и c (има заделено само памет)
- инструкции:
  1. премести ‘a’ от RAM паметта в регистър 1
  2. премести ‘b’ от RAM паметта в регистър 2
  3. събери стойностите на рег. 1 и 2 и запиши резултата в рег. 3
  4. Премести стойността на рег. 3 в c променливата

3.  Изпълним файл преминава през loader-a и се създава процес, който е поредица от байтове. В този процес се съдържат следните параметри (данни, инструкции, контекст):

- данни: a, b, c (става 15 накрая)
- инструкции: [1] [2] [3] [4] (пише номер на конкретен регистър)
- контекст: ?????

  Като имаме следната архитектура на процеса (номер -> инструкция/и):

  1. -> 1 и 2 (преместване)
  2. -> 3
  3. -> 4
     (т.е. имаме 3 типа инструкции)

Операционната система казва да се изпълни този процес:

- Процесор:
  - Регистри за данни (5; (garbage value); (garbage value)) [в нач. има само garbage val]
  - Контролни:
    - Брояч: 0 (в началото) -> 1
- Инструкция: 1 (след като се декодира инструкцията достигат дотук декодирани)

След това процесът се повтаря: Брояч -> Инструкция -> Записване на резултат в регистъра за данни (това е тялото на цикъла)

Накрая: C = 15;

Процесът и loader-а живеят в RAM паметта.

\*текстова версия на следната снимка:

![от код до процес](assets/proc_exec.png)

### Прекъсване и обработка на прекъсване

Това е нормалната работа на процесора. Тя може да бъде прекъсната от Прекъсвания (Interrupt).

Едно прекъсване (interrupt) може или да се игнорира, или да се обработи.

1. Когато се появи прекъсване, процесорът преминава в защитен режим на работа.
1. Като след това трябва да се реши дали ще се обработи това прекъсване.

   - Ако няма да се обработи - преминава се обратно към предходното състояние, преди самото прекъсване.

1. Ако реши да го обработи, първо запазва състоянието си на работа в момента и след това обработва прекъсването (изпълнява конкретна функция (базирано на типа прекъсване, etc.)).
1. След това продължава работата си.
1. Първо проверява дали има нови прекъсвания, подадени в момента на обработване на прекъсването. Прекъсванията се обработват по приоритет.
1. Като се обработят всички прекъсвания, процесорът възстановява нормалния си режим на работа.

За всеки тип прекъсване има Interrupt handler. Прекъсванията се пазят в приоритетна опашка. Interrupt handler се пази в RAM паметта.

**_Прекъсване не може да прекъсне обработката на прекъсване!_**

---

Има както и хардуерни, така и софтуерни прекъсвания.

- Хардуерните

  Хардуерните прекъсвания се получават се от външни хардуерни компоненти, свързани към, или част от компютърната система.

  Примери:

  - Прекъсваия от входно-изходни устройства - за получаване или изпращане на данни или при настъпване на събитие (напр. приключило е дадена операция)
  - Прекъсвания от таймер - времеделни прекъсвани
  - Проблем с някое от хардуерните устройства на компютъра

- Софтуерните

  Софтуерните прекъсвания се получават се при проблеми с изпълнението на инструкциите на даден процес.

  Примери:

  - деление на нула
  - overflow
  - опит за достъп на памет, която не принадлежи на съответния процес
  - при предаване на контрола на ядрото и преминаването на процесора в привилегирован режим и обратно

### Управление на входно-изходни устройства

Операционната система предоставя 3 механизма за работа с входно-изходни устройства:

- Синхронен входно-изходен механизъм (Synchronous I/O)

  Oперационната система изисква от дадено устройство да свърши определена работа и влиза в безкраен цикъл (infinite loop). Като постоянно пита устройството дали си е свършило работата. Този цикъл едва ще приключи (brek-не) чак когато чак когато устройството си свърши работата.Тогава то дава резултата в буфер, който операционната система прехвърля в RAM паметта. Синхронно е, защото ОС не прави нищо друго, освен да чака, докато не получи сигнал, че работата е свършила.

- Асинхронен входно-изходен механизъм (Asynchronous I/O)

  При асинхронния механизъм операционната система отново се допитва до устройството да свърши някаква работа. Но тук идва и разликата от синхронния тип. Докато В/И устройство си върши възложената задача, операционната система е свободна да върши други неща. И чак, когато е готово,устройството, то изпраща прекъсване (interrupt), което, при обработка от процесора, се handle-ва по същия начин като при синхронното: връща се резултат в буфера, който операционната система прехвърля в RAM паметта.

- Директен достъп до паметта (Direct Memory Access)

  При ДДП операционната система казва на дадено устройство не само да изпълни някаква задача, но и да я запише само в RAM паметта и след това да му изпрати прекъсване (interrupt). Понеже не се получава резултат от входно-изходното устройство, при Direct Memory Access няма буфери, защото няма кой да ги обработи и устройството директно пише в паметта. Операционната система получава прекъсване от устройството чак след като то си е свършило работата и е прехвърлило резултата в RAM паметта.

### Кеширане

Кеширането (caching) е принцип, при който информацията (най-нужна от cpu-то) трябва се държи максимално близко до процесора в памет, която има бърз достъп, с цел бързина.

Като така най-нужната информация (данни, инструкции, процеси, т.н.) се държи в най-бързата памет, най-близо до процесора, за да няма забавяния. Проблемът възниква, когато погледнем пазара и днешните технологични процеси (скорост, обем и бързина).

Най-бързата памет са регистрите, последвани от L1 кеш, след това L2, L3, RAM паметта и така до storage устройствата. Обратното може да се каже за цената на паметта за един байт, където регистрите не могат да се сравняват с мегабайтите на кеш паметта, както и кеш паметта не може да се сравнява с гигабайтите на RAM паметта и т.н.

Това е причината да има пъти по-малко регистри и кеш от RAM паметта. Което ни довежда, че кеширането трябва да е наистина оптимално и да се използва възможно най-много. Fun fact - кеш паметта всъщност заема най-много пространство от силиция на един процесор.

---

## Вътрешно устройство на операционната система

### Цели на ОС

- **_Многозадачност_** - Операционната система създава илюзия (абстракция) за паралелно изпълнение на програми. Обаче в реалността\* обработката на инструкции е последователна. разделя работата за изключително бърз период от милисекунди. Илюзията за многозадачност (паралелно изпълнение) се постига чрез използване на таймери, които генерират прекъсвания на определено време (интервал). Тези прекъсвания сменят процеса (задачата), която се изпълнява.

  \*технически в реалността се изпълнпват и много задачи, ако процесорът е многоядерен (и може би ако има няколко логически ядра (не съм сигурен за лог. ядрата обаче)).

  Иначе цялото това нещо (илюзията) се постига благодарение на невероятната скорост на днешните процесори. (говоря за едноядерни процесори тук :))

- **_Многопотребителност_** - в реална среда компютрите се използват от много потребители. Многопотребителността е способността на операционната система да поддържа различни (множество) потребители. Като така се постига енкапсулация. Дадени потребители да имат достъп до дадени файлове и директории. Както и всеки потребител да си има права / правомощия. В GNU+Linux има 2 типа потребители: привилегирован (root) и непривилегирован.

### Структура

Операционната система може да се раздели на две части:

- Ядрото (Kernel) - най-ниското ниво на една операционна система, то се грижи за управлението на различните части на една компютърна система - т.е. директно управлява хардуера. Това е единственият компонент, който може да работи в привилегиран режим (privileged mode). Ядрото съдържа всички драйвери за устройствата, които се намират в компютърната система. Ядрото съдържа и всички вътрешни функции (system calls - системни повиквания), които се използват от другите части на операционната система.

- Обвивката (Shell) - командния интерпретатор е набор от приложни програми, които знаят как да говорят с ядрото чрез системни извиквания, които то предоставя както и на обвивката, така и на приложните програми. Предоставя среда и интерфейс за улеснена работа с операционната, както на хора, така и на други приложни програми.

![kernel shell](assets/kernel_shell.png)

### Ядрото

Ядрото може да се раздели на 5 части:

- Управление на процесите (Process Management)

Управление на процесите -> След като даден процес се изпълни, той се терминира. От една програма може да се изпълнят няколко процеси, те могат да живеят едновременно или един след друг. Във всеки един момент всеки един процес изпълнява точно една програма. Процесът е абстракция на ОС; всеки процес се асоциира с една програма. Когато се създаде процес, той изпълнява инструкциите от горе на долу. ОС може да създава и терминира процесите. ОС може също така и да спира процесите (напр. ако имаме по-приоритетна задача) и да стартира процеси, които са спрени (продължава). ОС предоставя механизми за комуникация и синхронизация на процеси. Нашите програми се изпълняват от нишки. Ние можем да кажем на ОС, че искаме нашата програма да се изпълнява от няколко нишки. Нишките са софтуерно нещо; абстракция на ОС. Когато имаме множествено процесори, ОС може да изпълнява части от нашия код едновременно. Чрез нишките програмата може да се изпълнява паралелно. Нишките са просто работници. На колко нишки се изпълнява програмата се определя от програмиста. За повече нишки трябва да се обърнем към ОС. Когато дадена нишка си свърши работата, тя умира. Всяка нишка се асоциира с отделен programming counter (т.е. помни до къде е стигнала). Всяка нишка се асоциира с един процес, но един процес може да се асоциира с няколко нишки. Нишките споделят ресурси. Дефиниция на нишка – единица за изпълнение на процес (сл. път по-добра). Чрез нишките процесите се изпълняват паралелно – основен плюс. Нишките са абстракцията, която ОС използва, за да разпредели процесорното време (нова дефиниция).

- Управление на паметта (Memory Management)

Управление на паметта (RAM) -> RAM паметта е огромен масив от байтове; енергозависим. ОС се грижи всички процеси да стигнат до RAM паметта и оттам до процесора. Резултатите на процесора също се записват в RAM. Ядрото има 3 функции, когато работи с паметта: да заделя и освобождава оперативна памет, когато е нужно; да следи кои части от паметта на кои процеси са; да решава кои данни и процеси трябва да са в RAM паметта

- Управление на входно-изходните устройства (I/O Management)

Управление на I/О устройства -> Всяко устройство има драйвер (програма, която знае как да работи точно с това устройство). Ядрото предоставя единен интерфейс за работа с типове устройства. Входно-изходната система също така кешира информация. Тази система има др. важна задача – spooling (концепция, при която се разделя работата на входно-изходното устройство на малки части заради хардуерни лимитации; пример: принтер и голям материал за принтене). Интерфейсът е конвенция; набор от правила. Устройства не знаят за този интерфейс. Драйверите са посредника между устройствата и интерфейса. Работа с I/O устройства се изпълнява с инструкции, които не могат да бъдат изпълнени в непривилегирован режим. Само ОС може да работи с хардуерната система директно.
Ядро <-> интерфейс <-> драйвер <-> буфер|устройство

- Управление на външно-запаметяващите устройства (Storage Management)

Управление на външни запаметяващи устройства -> Тези устройства се използват за съхранение на данни, които искаме да оцелеят при спиране на системата и които не се побират за RAM-а. Типове: WORM (Записвайте веднъж четете много (WORM) описва устройство за съхранение на данни, в което информацията, веднъж написана, не може да бъде модифицирана. Тази защита срещу запис гарантира, че данните не могат да бъдат подправени, след като бъдат записани на устройството), RW. Хардуерните устройства се различават по скорост, обем и начин на работа. Целта на ядрото е да скрие тези различия. За нас всичко е различни файлове, поредица от файлове. Файлова система – съвкупност от файлове, директории и правата за достъп до тези файлове и директории. Целта на директориите е организираност. Ядрото реализира две абстракции: файл и файлова система, които позволяват да се управляват външни запаметяващи устройства. ОС може да създава, трие, мести, променя съдържание, да променя правата за достъп.

- Имплементация на защитна сигурност (Security)

Имплементация на защита и сигурност -> Защита – всеки механизъм на ОС, който контролира достъпа на потребители до процеси. Има два типа защити: хардуерни (примери: съществуването на двата режима на работа – привилегирован и непривилегирован; има хардуерни защити за това кои байтове от RAM паметта могат да бъдат достъпвани в непривилегирован режим; таймерите на процесора са др. пример, т.е. един таймер не може да работи постоянно) и софтуерни (примери: правилата за достъп до файлове и директории; всеки процес се асоциира с точно определена памет, ако достъпи памет, която не му принадлежи, процесът биват убит).

---

## Видове архитектури на операционни системи и виртуализация

### Монолитни ядра (Monolithic kernels)

### Многослойни ядра (Layered kernels)

### Микроядра (Microkernels)

### Виртуализация

Virtual Machines

ОС -> Управлява хардуер
ОС -> нещото, с което ПП си комуникират
ОС -> нещото, което разпределя … на програмите

ОС -> дава абстракция и крие едни процеси в други

Така виртуалните машини се крият в един процес. Идеята е да се създадае илюзията на ОС, че има даден хардуер.

ОС може да алокира определен ресурс на виртуална машина. И виртуалните машини не знаят за своето съществуване. Единственото, което виждат е, че те са единствената ОС.

БОНУС -> създават изолация, която не знае, че съществува

Контейнер – процес и ресурсите, които този процес използва в дадена изолацоя


ОС управлява хардуер и това кои програми в кой момент се изпълняват. ОС може да създаде илюзията, че някакъв процес работи самичък; ОС може да скрие съществуването на дадени процеси от други процеси. Виртуалните машини са процеси, които си мислят, че работят с уникален хардуер.
	       ОС
                       |
PC -> VM1 ------> hardware
|                                  |
VM2 ------------------->

VM1 и VM2 не знаят за своето съществуване, те мислят, че единствени управляват хардуера. Виртуалните машини създават изолация. Контейнер – процес и ресурсите, които този процес използва в някаква изолация.


---

## Процесите в детайл

Процес е програма по времето на своето изпълнение. От една програма магат да бъдат инстанцирани множество процеси, което позволява на потребителя да изпълнява една програма многократно. Обаче един процес може да се асоциира само с една програма - т.е. един процес е инстанция САМО на една програма.

---

# Практика

## Macros | Макроси

## Basic Linux команди

- `whoami` - "Who am I? 😮" - връща името на текущия потребител

  <img width="123" alt="image" src="https://user-images.githubusercontent.com/46886807/197382296-0bc4246a-b612-4878-8378-f7bad3d781bd.png">

- `pwd` - "Print work directory" - посочва директорията, в която се намираме

  <img width="184" alt="image" src="https://user-images.githubusercontent.com/46886807/197382316-11b87ed5-0ee7-4708-85c8-2c75ca009586.png">

- `ls` - "List" - дава информация за това какви файлове и директории има в текущата директория

  <img width="426" alt="image" src="https://user-images.githubusercontent.com/46886807/197382371-47447a0b-39f7-4176-8fb1-7342a86cb0ee.png">

- `mkdir <name>` - "Make directory" - създава директория на име <name> там, където се намираме

  <img width="569" alt="image" src="https://user-images.githubusercontent.com/46886807/197382405-844e65cb-7a1a-4139-977f-1ed09c8173dd.png">

- `mv` <src> <dest> - "Move" - премества избрания файл на дадена локация (може да се използва и за преименуване на дадения файл) (може да се използва и за директории)

- `cp <src> <dest>` - "Copy" - копира избрания файл на дадена локация (може да се използва и за директории)

- `cd` - "Change Directory" - премества потебителя в дадена директория

  - `cd <name>` - премества потребитя в подадената от него директория с път <name>

    <img width="275" alt="image" src="https://user-images.githubusercontent.com/46886807/197382680-e1eecf1e-1faa-4115-98d2-edcdbeb9a687.png">

  - `cd ..` - премества потребителя с една директория нагоре (във "файловото дърво" - file structure tree)

    <img width="297" alt="image" src="https://user-images.githubusercontent.com/46886807/197382485-7445557e-a495-4734-b736-a3e079909080.png">

  - `cd .` - "премества" потребителя в текущата директория

    <img width="201" alt="image" src="https://user-images.githubusercontent.com/46886807/197382505-23e65f9a-8107-4f9c-85b5-b87dc1ca6717.png">

  - `cd /` - премества потребителя в **ROOT** директорията

    <img width="222" alt="image" src="https://user-images.githubusercontent.com/46886807/197382519-b3a3ee7f-9c75-4b19-ba8c-d149ae809df6.png">

  - `cd ~` - премества потребителя в съответната за него **HOME** (потребителска) директория

    <img width="88" alt="image" src="https://user-images.githubusercontent.com/46886807/197382553-000b7245-c204-4d96-acd4-b3be4eaf6e30.png">

- `touch <name>` - създава файл на име <name> без да го отваря

  <img width="405" alt="image" src="https://user-images.githubusercontent.com/46886807/197382717-3a3b8813-2b60-4ef0-9596-845f7d65fdb3.png">

- `cat <name>` - "Concatenate" - извежда (конкатенира) стойността на даден файл

  <img width="383" alt="image" src="https://user-images.githubusercontent.com/46886807/197383141-32c9e09b-73f8-4b32-9ff5-ad4d3c7ccbb4.png">

- `man` - "Manual page" - документация за функции и команди

  - `man <name>` - "General commands menu" - документация за обикновени функции и команди

    <img width="682" alt="Screenshot 2022-10-23 at 11 39 22 AM" src="https://user-images.githubusercontent.com/46886807/197382961-c0dc8218-7305-4786-ad48-7035a7ad2c66.png">

  - `man 2 <name>` - System calls menu - документация за системни функции и команди (System Calls - системни повиквания)

    <img width="682" alt="Screenshot 2022-10-23 at 11 46 26 AM" src="https://user-images.githubusercontent.com/46886807/197382984-8007049c-3202-4fa2-80c7-b4b200efa527.png">

- `vim <name>` - vim (което означава vi (стар текстов редактор) improved) е изключително **_основан_** текстов редактор за терминал (btw води се за един от най-ефикасните и мощни редактори) - чрез тази команда или създаваме и отваряме за редактиране файл <name>, или само отваряме вече съществуващ файл <name>

       <img width="389" alt="image" src="https://user-images.githubusercontent.com/46886807/197383057-d83a8eb4-20b7-4ec8-9fb9-a04914f2d493.png">

  <img width="682" alt="image" src="https://user-images.githubusercontent.com/46886807/197383063-8b13df9d-a18b-42bf-9d19-57fa60526c09.png">

- `nano <name>` - изключително опростен текстов редактор, който "върши работата". Най-често се използва за редактиране на кофигурационни файлове. Тази команда върши всичко аналогично на vim само че с nano

       <img width="389" alt="image" src="https://user-images.githubusercontent.com/46886807/197383085-c31c8cec-1e65-4196-bf66-1d80c608cbaa.png">

  <img width="682" alt="image" src="https://user-images.githubusercontent.com/46886807/197383105-e98f1373-8adf-420d-ae85-712af2b59d48.png">

---

## Файлове и файлови дескриптори

Функции, които ще учим за файлове:

- open
- close
- read
- write
- lseek

---

## Работа с байтове и комуникация

### Endianness

- little endian

- big endian

### <stdint.h>

- uint8_t

- uint16_t

- uint32_t

- uint64_t

### Bob & Alice

### Видове комуникация

- shared memory
- pipes
- sockets
- signals
- files
